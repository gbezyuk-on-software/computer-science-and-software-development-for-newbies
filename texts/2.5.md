# Размер задач. Задача о ханойской башне

## Вступление

Мы продолжаем знакомство с концепцией размера задачи, и переходим от бинарного поиска из вступительной лекции CS50 к задаче о Ханойской Башне, изложенной в "Конкретной Математике" Кнута.

## Задача о ханойской башне

![скрин "Конкретной Математики" о Ханойской Башне](./img/2.5/hanoi-intro.png)


### Описание задачи

Есть три стержня. На первый нанизана упорядоченная пирамидка из N дисков, так что внизу — самый крупный, вверху — самый маленький. Единственная допустимая операция — перекладывание диска с одного стержня на другой. Больший диск положить класть сверху на меньший запрещается. Цель задачи — перенести пирамидку целиком с одного диска на другой за минимальное количество операций (перекладывания диска).

На примере этой задачи хотелось бы не только продолжить рассмотрение концепций размера задачи, сложности алгоритма и рекурсии/реккурентности, но и проиллюстрировать процесс выработки алгоритма и структуры данных, необходимых для формального (то есть доступного для кодирования) решения задачи.


### Первые попытки решения задачи

Практически для всех задач, параметризированных по их размеру (в нашем случае дисков может быть любое натуральное N) полезно начать с попыток определения тривиальных решений для малых N. В нашем случае начнём с ответа на простой вопрос: сколько и каких операций необходимо для перекладывания пирамидки из одного единственного диска с первого стержня на третий?


#### Решение задачи для случая с одним единственным диском (N = 1)

 Ответ, конечно, очевиден: переложить нужно этот один единственный диск. Как мы его запишем? Давайте сразу начнём использовать английский в наших записях. `Move` значит "подвинуть, переместить" — так и назовём нашу первую функцию. Перемещаем мы диск со стержня на стержень — стало быть, у функции должно быть два параметра.

```javascript
move(1, 3) // может быть, стоит записывать операцию переноса диска с первого стержня на третий так?
move(departure_rod, destination_rod) // а обобщённо, со стержня departure_rod на стержень destination_rod — так?
// выглядит неплохо
// кстати, "departure" по-английски — "отправление", "destination" — "назначение",
// эти слова вы могли видеть в аэропорту или на вокзале
// а "rod", разумеется, переводится как "стержень"
```

Помимо атомарной операции перемещения, у нас ещё есть собственно решение задачи целиком. Назовём эту функцию `solve_hanoi` — "решить (задачу) ханой(-ской башни)". Какие у неё могут быть аргументы? Как минимум, высота башни — N. А каково само решение? Пока не ясно в общем случае, но уже понятно что делать для случая с единственным диском: просто переложить его, не мудрствуя лукаво.

```javascript
function solve_hanoi(N) {
    if (N == 1) {
        move(1, 3);
        // заметим, что функция `move` у нас до сих пор толком не определена
        // мы пока не столько пишем код, сколько размышляем и пытаемся нащупать решение
    }
}
```

Минуточку, а почему это мы перемещаем пусть даже единственный диск именно *с первого стержня на третий*? Ведь задача может быть сформулирована и для пирамидки, изначально расположенной, например, на втором стержне, или для переноса её не на третий, а на второй стержень! Выходит, надо добавить параметров: объявление `solve_hanoi(N)` превратится в `solve_hanoi(N, departure_rod, destination_rod)`, а определение будет следующим:

```javascript
function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        move(departure_rod, destination_rod);
        // изменилось только лишь то, что мы заменили константы 1 и 3
        // на параметры departure_rod и destination_rod
    }
}
```

Здорово, конечно, но и функцию move надо бы определить. Как будем хранить данные? Нам нужно знать а) какие диски лежат на каком стержне и б) в каком порядке. А самих стержней — три. Вполне подойдёт массив из трёх элементов, как-то описывающих состояние стержня (количество и порядок дисков на нём). Количество и порядок дисков тоже вполне неплохо представить в виде массива. Для исходного условия задачи с одним единственным диском получим такую конструкцию: `[[1], [], []]`, а решением её должно будет стать `[[], [], [1]]` — единственный диск перенесён с первого стержня на второй. Структура данных диктует нам алгоритм: функция `move` должна переводить одно состояние в другое. Само состояние давайте пока считать глобальным. Немного подумав, можно записать полученный подход таким псевдокодом:

```javascript
hanoi_1 = [ // начальное состояние для задачи с одним единственным диском
    [1], // на первом стержне лежит наш диск
    [], // второй стержень пуст
    [] // третий — тоже
]

function move(departure_rod, destination_rod) {
    // 1. снять диск со стержня departure_rod
    // (то есть удалить его из массива hanoi_1[departure_rod])
    // 2. положить снятый диск на destination_rod
    // (то есть добавить его к массиву hanoi_1[destination_rod])
}
```

Возникает вопрос как именно снимать и класть диски — то есть, как именно добавлять или удалять элементы из массива в используемом языке. Это вопрос реализации, и в используемом нами языке JavaScript у массивов есть свои методы. В нашем простейшем случае мы можем обойтись даже тупой заменой массива, представляющего стержень:

```javascript

function move(departure_rod, destination_rod) {
    hanoi_1[departure_rod] = []
    hanoi_1[destination_rod] = [1]
    // тупо донельзя, но для задачи размера 1 — сойдёт и так
}
``` 

Выглядит откровенно хреново? Так и есть, отрицать не будем. Но мы ведь занимаемся поиском решения, а не его оптимизацией — до оптимизации ещё дойдём. Мы даже можем запустить в консоли этот код — и он сработает: `solve_hanoi(1, 0, 2)`, (решить задачку для случая единственного диска, перекладывая со стержня с индексом 0 на стержень с индексом 2). Но давайте перейдём к случаю с двумя дисками.


#### Решение задачи для случая с двумя дисками (N = 2)

Воспользуемся полученным на предыдущем шаге форматом данных, и опишем исходное условие и желаемый результат:

```javascript
// исходное состояние для N = 2
hanoi_2 = [[1, 2], [], []]
// желаемый результат
hanoi_2_desired_result = [[], [], [1, 2]]
```

На первом стержне у нас уже два диска, в первом массиве — два объекта. Логично их пронумеровать: первый диск и второй, мы так и поступили. Нужно учесть порядок дисков: давайте считать, что первой цифре в массиве соответствует самый верхний диск, а последней — самый нижний. Можем ли мы поступить наоборот? Да запросто, лишь бы этот порядок соблюдался для всех стержней, и учитывался при перемещений (брать можно всегда только самый верхний диск).

Вспомним, какие у нас есть ограничения для операции перекладывания диска? Во-первых, мы всегда обязаны брать самый верхний диск. Значит, если верхний диск мы договорились представлять первой цифрой массива, массив "отправления" покидать должна всегда именно она. Во-вторых, запрещено класть больший диск сверху на больший — значит, перед перекладыванием нам стоит проверить, не находится ли наверху целевого стержня диск меньше, чем на исходном. Состояние, которое запрещено правилами (постановкой задачи) будем называть запрещённым состоянием. Запрещёнными состояниями для задачи размера N = 2 являются [[2,1], [], []] и два аналогичных на других стержнях: [[], [2, 1], []], [[], [], [2,1]] — все в силу того, что болший (второй) диск лежит сверху на меньшем.

Давайте изменим функцию `move` так, чтобы она удовлетворяла нашим правилам. Сначала без проверки, само действие перекладывания:

```javascript
function move(departure_rod, destination_rod) {
    top_disk = hanoi_2[departure_rod].shift() // снимаем диск сверху со стержня departure_rod
    hanoi_2[destination_rod].unshift(top_disk) // кладём его сверху на стержень destination_rod
}
```

Мы использовали встроенные методы работы с массивами JavaScript `shift` и `unshift`. Они делают как раз то, что нам нужно: первая забирает элемент из начала массива, вторая — напротив, добавляет элемент в начало массива. В рамках используемой метафоры так и получается: сняли диск, положили диск. Можно, кстати, обойтись и без промежуточной переменной `top_disk` ("верхний диск"), и записать сразу такое выражение: `hanoi_2[destination_rod].unshift(hanoi_2[departure_rod].shift())` — но мы так выпендриваться пока не будем, читается оно ощутимо хуже. Преждевременная оптимизация — корень многих зол, нам пока важнее понимать, что мы делаем — а не делать это очень быстро и эффективно.

Добавим проверку? А давайте вынесем её в отдельную функцию, она ведь имеет самостоятельным смысл. Назовём, скажем `is_move_possible` — "возможно ли перемещение"? Заодно и игра слов красивая проявится — "move"-то по-английски ещё и "ход" (в игре) обозначает. Ваш ход, господин программист.
Давайте подумаем. Мы точно можем переложить любой диск на пустой стержень, и мы точно можем переложить диск на стержень, верхний диск на котором больше перекладываемого. В остальных случаях мы, похоже, будем нарушать правила. Ещё момент: с уже пустого стержня мы ничего никуда переложить не можем — ну нечего же перекладывать =) Закодируем!

```javascript
function is_move_possible(departure_rod, destination_rod) {
    if (departure_rod.length == 0) {
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    return destination_rod[0] > departure_rod[0];
}
```

Честно говоря, понадобится ли нам эта функция на практике — вопрос; верно описанный алгоритм должен бы учитывать "правила игры" сам. Но полезна она уже хотя бы для углубления понимания происходящего, как любой пример. Пока что давайте добавим `is_move_possible` как проверку в нашей функции `move`:

```javascript
function move(departure_rod, destination_rod) {
    // ранее описанные действия по перекладыванию диска будем выполнять только если это разрешено правилами
    if (is_move_possible(departure_rod, destination_rod)) {
        top_disk = hanoi_2[departure_rod].shift() // снимаем диск сверху со стержня departure_rod
        hanoi_2[destination_rod].unshift(top_disk) // кладём его сверху на стержень destination_rod
    }
}
```

Надо сказать, что дальнейший рост размера задачи (N = 3, 4, ... сколько угодно) усложнения `move` и тем более `is_move_possible` не потребует, так что теперь можно сконцентрироваться на `solve_hanoi` — действительном решении задачи. Для случая с одним диском нам требовалось всего лишь переложить один диск. Напомним себе, что код выглядел так (я просто скопировал его сверху без изменений):

```javascript
function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        move(departure_rod, destination_rod);
    }
    if (N == 2) {
        // а вот здесь стоит подумать:
        // какие именно перемещения нам необходимы для переноса пирамидки из двух дисков?
    }
}
```

Оторвёмся на секунду от кода. Представим три стержня, на первом — лежит пирамидка из двух дисков, меньший (#1) сверху на большем (#2). Как перенести пирамидку на третий стержень за минимальное количество действий, ни разу не положив большой диск сверху на маленький? Вроде бы несложно: переложим маленький диск на второй стержень, затем большой диск на третий (целевой) стержень, и затем со второго стержня маленький диск на третий. Всего три операции, красота. Важно заметить, однако, что у нас в работу вступил второй диск — назовём его промежуточным, "intermediate" (хотя в рамках метафоры аэропорта можно было бы назвать и трансферным, но метафоры стоит вовремя притормаживать). Как понять, какой стержень можно считать промежуточным? Очень просто — тот, который остаётся, когда из трёх имеющихся выберут исходный (departure) и целевой (destination). Иными словами, когда из `[1, 2, 3]` уже забрали `1` и `3` — остаётся только `2`, а если заберут `2` и `3` — останется только `1`. Остаётся добавить поправку на нумерацию стержней с нуля в нашем случае (мы ведь используем массив), и закодировать:

```javascript
function get_intermediate_rod(departure_rod, destination_rod) {
    // исходный массив стержней — просто три цифры
    all_rods = [0, 1, 2]
    
    // отфильтруем departure_rod встроенной функцией
    rods_without_departure = all_rods.filter(function (rod) { return rod != departure_rod })
    
    // отфильтруем destination_rod встроенной функцией
    only_one_rod_left = rods_without_departure.filter(function (rod) { return rod != destination_rod })
    
    // в all_rods должен к этому моменту остаться только один элемент,
    // его и вернём как номер промежуточного стержня:
    return only_one_rod_left[0]
}
```

Умея получать промежуточный стержень, мы можем сформулировать решение для N = 2:

```javascript
function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        // просто перекладываем один диск
        move(departure_rod, destination_rod);
    }
    if (N == 2) {
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod = get_intermediate_rod(departure_rod, destination_rod)

        // перекладываем маленький диск на промежуточный стержень
        move(departure_rod, intermediate_rod)
        
        // перекладываем большой диск на целевой стержень
        move(departure_rod, destination_rod)
        
        // маленький диск с промежуточного стержня перекладываем на целевой
        move(intermediate_rod, destination_rod)
    }
}
```

Выглядит неплохо, должно работать. Но как бы расширить решение на случай N = 3, а лучше — вообще для любого N?


#### Решение задачи для случая с тремя дисками (N = 3)

Для случая с тремя дисками решение становится уже сложнее: действий больше, в голову сразу все могут и не поместиться, да и что делать — не так уж с ходу и понятно. Дисков всего три, а задачка-то получается уже большая. Что нам в таком случае может посоветовать программист, математик, или толковый римский император? "Разделяй и властвуй!" — вот что. Нужно попробовать свести большую задачу к такой же, но меньшей. То есть, свести задачу для пирамидки из трёх дисков к задаче для пирамидки из двух. Для каких из двух? Ну например для двух верхних. Можем мы переложить два верхних диска, соблюдая все правила? Да как нефиг делать, мы же в предыдущем разделе как раз этим занимались. Обязаны мы перекладывать на третий стержень, или можем и на второй тоже? Не обязаны, на какой захотели — на тот и переложили. То есть, мы можем получить из исходного состояния `[[1, 2, 3], [], []]` за три действия (см. алгоритм для N == 2) состояние `[[3], [1,2], []]` вызвав `solve_hanoi(2, 0, 1)` (параметры расшифровываются так: перекладываем 2 диска, со стержня с номером 0 на стержень с номером 1, в привычно-человеческой нумерации — с самого левого, стартового стержня, на средний (промежуточный)). Уже неплохо — мы задействовали решение задачи для меньшего размера в рамках решения для большего, это — явно шаг в верном направлении. К тому же, мы сформулировали действие "переложить верхнюю часть пирамиды из M дисков", причём M у нас равно (N-1) — первым параметром в `solve_hanoi` мы передаём ведь именно размер задачи (то есть количество дисков для перекладывания).
Из состояния `[[3], [1,2], []]` перейти ещё на шаг ближе к цели (а цель у нас `[[], [], [1,2,3]]`) — просто, нужно всего лишь переложить третий диск на третий стержень: `[[], [1,2], [3]]`, это атомарная операция `move(0, 2)` (стержни нумеруются с нуля, помним?). Теперь у нас самый большой диск на третьем стержне, пирамидка из двух оставшихся — на втором, первый — пуст. Умеем мы перекладывать пирамидку из двух со стержня на стержень? Умеем! Имеет ли значение, что на этом стержне уже есть диск? Покуда диск больше, чем самый крупный диск перекладываемой пирамидки — нет, не имеем. Так давайте сделаем из `[[], [1,2], [3]]` наше искомое `[[], [], [1,2,3]]` простым вызовом `solve_hanoi(2, 1, 2)`. Задачка-то — того, решена! Давайте выпишем из нашего слегка сумбурного объяснения суть: те операции, которые мы выполнили.

```javascript
// N = 3, начинаем с исходной:
hanoi = [[1,2,3], [], []]

// переносим верхнюю пирамидку с первого диска на второй (промежуточный)
// задействуем уже имеющееся решение для N = 2
// [[1, 2, 3], [], []] => [[3], [1,2], []]
solve_hanoi(2, 0, 1)

// переносим оставшийся на левом стержне самый крупный диск на правый
// [[3], [1,2], []] => [[], [1,2], [3]]
move(0, 2)

// переносим пирамидку из двух дисков с промежуточного стержня на целевой
// снова задействуем уже имеющееся решение для N = 2
// [[], [1,2], [3]] => [[], [], [1, 2, 3]]
solve_hanoi(2, 1, 2)
```

Добавим код на случай N = 3 в нашу функцию `solve_hanoi`:

```javascript
function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        // просто перекладываем один диск
        move(departure_rod, destination_rod);
    }

    if (N == 2) {
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod = get_intermediate_rod(departure_rod, destination_rod)

        // перекладываем маленький диск на промежуточный стержень
        move(departure_rod, intermediate_rod)
        
        // перекладываем большой диск на целевой стержень
        move(departure_rod, destination_rod)
        
        // маленький диск с промежуточного стержня перекладываем на целевой
        move(intermediate_rod, destination_rod)
    }

    if (N == 3) {
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod = get_intermediate_rod(departure_rod, destination_rod)

        // перекладываем верхнюю пирамидку из 2 дисков на промежуточный стержень
        solve_hanoi(2, departure_rod, intermediate_rod)
        
        // перекладываем самый большой диск на целевой стержень
        move(departure_rod, destination_rod)
        
        // пирамидку с промежуточного стержня перекладываем на целевой
        solve_hanoi(2, intermediate_rod, destination_rod)
    }
}
```

Очевидна схожесть веток для N = 2 и N = 3. И там и там три действия: положить на промежуточный стержень, перенести на целевой стержень самый крупный диск, перенести с промежуточного стержня на целевой. Отличается лишь то, что в N = 3 мы перекладываем на промежуточный диск пирамидку, а для N = 2 — одиночный диск. Но ведь пирамидка из одного диска — это и есть сам диск, значит для N = 2 мы делаем то же самое, что и для N = 3! Давайте упростим код (попросту выкинув ветку N = 2, она нам больше не нужна — у нас есть общее решение!) Единственное, что нужно учесть — что `2 == 3 - 1` =)

```javascript
function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        // просто перекладываем один диск
        move(departure_rod, destination_rod);
    }
    // для всех N > 1
    else {
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod = get_intermediate_rod(departure_rod, destination_rod)

        // перекладываем верхнюю пирамидку из 2 дисков на промежуточный стержень
        solve_hanoi(N - 1, departure_rod, intermediate_rod)
        
        // перекладываем самый большой диск на целевой стержень
        move(departure_rod, destination_rod)
        
        // пирамидку с промежуточного стержня перекладываем на целевой
        solve_hanoi(N - 1, intermediate_rod, destination_rod)
    }
}
```

Ура, мы решили задачу. Кажется. Без проверки — нельзя быть уверенным ни в чём наверняка, так давайте проверять.

#### Проверка и отладка

Для начала, запишем всё что мы тут намудрили за предыдущие 300+ строчек текста и кода:

```javascript
function is_move_possible(departure_rod, destination_rod) {
    if (departure_rod.length == 0) {
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    return destination_rod[0] > departure_rod[0];
}

function move(departure_rod, destination_rod) {
    // действия по перекладыванию диска будем выполнять только если это разрешено правилами
    if (is_move_possible(departure_rod, destination_rod)) {
        top_disk = hanoi[departure_rod].shift() // снимаем диск сверху со стержня departure_rod
        hanoi[destination_rod].unshift(top_disk) // кладём его сверху на стержень destination_rod
    }
}

function solve_hanoi(N, departure_rod, destination_rod) {
    if (N == 1) {
        // просто перекладываем один диск
        move(departure_rod, destination_rod);
    }
    // для всех N > 1
    else {
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod = get_intermediate_rod(departure_rod, destination_rod)

        // перекладываем верхнюю пирамидку из 2 дисков на промежуточный стержень
        solve_hanoi(N - 1, departure_rod, intermediate_rod)
        
        // перекладываем самый большой диск на целевой стержень
        move(departure_rod, destination_rod)
        
        // пирамидку с промежуточного стержня перекладываем на целевой
        solve_hanoi(N - 1, intermediate_rod, destination_rod)
    }
}
```

Как и в прошлый раз, копируем этот код в консоль браузера:
![Копируем код для задачи ханойской башни в браузер](./img/2.5/hanoi-tower-console-1.png)

#### Проверка работоспособности для N = 1

Теперь давайте проверим работу алгоритма для N = 1. Определим глобальную переменную `hanoi` с исходным состоянием `[[1], [], []]`, запустим алгоритм `solve_hanoi(1, 0, 2)`, и посмотрим что получится — что изменится в `hanoi`:

```javascript
hanoi = [[1], [], []]
solve_hanoi(1, 0, 2)
JSON.stringify(hanoi)
// JSON.strintify — пока воспринимайте как магию,
// позволяющую преобразовать массив в строку
```

![Пробуем запустить для N=1](./img/2.5/hanoi-tower-console-2.png)

Упс! Похоже, ничего не произошло? О_О  >_< o_O O_o Как же так? Что делать? Как быть? Кто подставил Кролика Роджера?

Нам бы отладчик, да не так-то просто до него из консоли дотянуться. Давайте применим технику массированных отладочных вызовов. Возьмём наш код и нашпигуем его `console.log`-ами по полной! Ну ладно, не по полной — в логику проверки `is_move_possible` пока не будем лезть:

```javascript
function move(departure_rod, destination_rod) {
    // действия по перекладыванию диска будем выполнять только если это разрешено правилами
    if (is_move_possible(departure_rod, destination_rod)) {
        console.log('moving from',  departure_rod, 'to', destination_rod, 'on state', JSON.stringify(hanoi))
        top_disk = hanoi[departure_rod].shift() // снимаем диск сверху со стержня departure_rod
        console.log('top disk is', top_disk)
        hanoi[destination_rod].unshift(top_disk) // кладём его сверху на стержень destination_rod
        console.log('result state is', JSON.stringify(hanoi))
    } else {
        console.log('move',  departure_rod, destination_rod, 'on', JSON.stringify(hanoi), 'is considered impossible')
    }
}

function solve_hanoi(N, departure_rod, destination_rod) {
    console.log('solve_hanoi for N = ', N, 'departure_rod = ', departure_rod, 'destination_rod = ', destination_rod)
    if (N == 1) {
        console.log('we are in the branch N == 1')
        // просто перекладываем один диск
        move(departure_rod, destination_rod);
    }
    // для всех N > 1
    else {
        console.log('we are in the branch N > 1')
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod = get_intermediate_rod(departure_rod, destination_rod)

        // перекладываем верхнюю пирамидку из 2 дисков на промежуточный стержень
        solve_hanoi(N - 1, departure_rod, intermediate_rod)
        
        // перекладываем самый большой диск на целевой стержень
        move(departure_rod, destination_rod)
        
        // пирамидку с промежуточного стержня перекладываем на целевой
        solve_hanoi(N - 1, intermediate_rod, destination_rod)
    }
}
```

![Обновлённый код ханойской башни, с отладочными вызовами](./img/2.5/hanoi-tower-console-3.png)

Попробуем запустить для N=1 ещё раз и посмотреть, что получится:

```javascript
hanoi = [[1], [], []]
solve_hanoi(1, 0, 2)
JSON.stringify(hanoi)
```

![Запуск с N == 1 и отладочными вызовами](./img/2.5/hanoi-tower-console-4.png)

Оп-па! Добавили отладку — всё стало сразу сильно понятнее. `move 0 2 on [[1],[],[]] is considered impossible` — почему-то наша проверка на возможность переноса вернула `false`, надо теперь только понять, почему. Самое время и туда отладочных вызовов добавить:

function is_move_possible(departure_rod, destination_rod) {
    if (departure_rod.length == 0) {
        console.log('move is impossible because the departure rod is empty')
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        console.log('move is possible because the destination rod is empty')
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    console.log('move is', destination_rod[0] > departure_rod[0] ? 'possible' : 'impossible',
                'because destination_rod[0] > departure_rod[0] is', destination_rod[0] > departure_rod[0])
    return destination_rod[0] > departure_rod[0];
}

![Больше отладочных вызовов богу отладочных вызовов!](./img/2.5/hanoi-tower-console-5.png)

Ииии ещё разочек запустим наш код — пусть расскажет, почему это нельзя нам такой ход делать, что за фигня?

```javascript
hanoi = [[1], [], []]
solve_hanoi(1, 0, 2)
JSON.stringify(hanoi)
```

![Запуск с N == 1 и отладочными вызовами, часть вторая](./img/2.5/hanoi-tower-console-6.png)

Ага. Чуть ближе к решению: `move is impossible because destination_rod[0] > departure_rod[0] is false`, значит мы доходим в функции `is_move_possible` до самого конца. Но минуточку, этого же быть не должно! Мы перекладываем единственный диск с "нулевого", непустого, стержня, на "второй" — пустой — условие `if (departure_rod.length == 0)` должно быть ложным, а вот `if (destination_rod.length == 0)` — истинным! Не должны мы до конца функции дойти. Давайте выясним, в чём же дело — просто посмотрим, чему равны значения `departure_rod`, `departure_rod.length`, и аналогичные для `destination_rod`. Добавим ещё отладочных вызовов? Почему бы и нет:

```javascript
function is_move_possible(departure_rod, destination_rod) {
    // вот здесь добавляем ещё одну отладку:
    console.log('is_move_possible debug information:')
    console.log('departure_rod:', departure_rod)
    console.log('departure_rod.length:', departure_rod.length)
    console.log('destination_rod:', destination_rod)
    console.log('destination_rod.length:', destination_rod.length)

    if (departure_rod.length == 0) {
        console.log('move is impossible because the departure rod is empty')
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        console.log('move is possible because the destination rod is empty')
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    console.log('move is', destination_rod[0] > departure_rod[0] ? 'possible' : 'impossible',
                'because destination_rod[0] > departure_rod[0] is', destination_rod[0] > departure_rod[0])
    return destination_rod[0] > departure_rod[0];
}
```

...и повторим в который уже раз наш тестовый вызов:
![Запуск с N == 1 и отладочными вызовами, часть третья](./img/2.5/hanoi-tower-console-7.png)

Что получили? Вот что:
```
departure_rod: 0
departure_rod.length: undefined
destination_rod: 2
destination_rod.length: undefined
```

Там, где мы ожидаем увидеть длину списка дисков на стержне — у нас `undefined`. А почему? Да потому что там, где мы ожидаем увидеть сам список — у нас его индекс! Ай-ай-ай! Проморгали! Почему проморгали? Некорректно назвали сущности, только и всего. Параметрами функции являются не сами списки-стержни, а их индексы. Поэтому правки стоит внести сразу во всех местах: не только определение `function is_move_possible(departure_rod, destination_rod)` стоит превратить в `function is_move_possible(departure_rod_index, destination_rod_index)`, но и `function move(departure_rod, destination_rod)` — аналогично, в `function move(departure_rod_index, departure_rod_index)`, да и сам `function solve_hanoi(N, departure_rod, destination_rod)` — в `function solve_hanoi(N, departure_rod_index, destination_rod_index)`. И ещё у нас есть `function get_intermediate_rod` — та же петрушка требуется и там. Чувствуете, как владение натуральным (английским) языком и точность формулировок оказываются важнейшими навыками программиста? Так-то — вперёд, гуманитарии! =) Вносим изменения:

```javascript

function get_intermediate_rod_index(departure_rod_index, destination_rod_index) {
    // исходный массив стержней — просто три цифры
    all_rods_indexes = [0, 1, 2]
    
    // отфильтруем departure_rod встроенной функцией
    rod_indexess_without_departure = all_rods_indexes.filter(function (rod) { return rod != departure_rod })
    
    // отфильтруем destination_rod встроенной функцией
    only_one_rod_index_left = rod_indexess_without_departure.filter(function (rod) { return rod != destination_rod })
    
    // в all_rods должен к этому моменту остаться только один элемент,
    // его и вернём как номер промежуточного стержня:
    return only_one_rod_index_left[0]
}

function is_move_possible(departure_rod_index, destination_rod_index) {
    // сами списки дисков на стержнях мы можем получить по их индексам
    departure_rod = hanoi[departure_rod_index]
    destination_rod = hanoi[destination_rod_index]

    // вот здесь добавляем ещё одну отладку:
    console.log('is_move_possible debug information:')
    console.log('departure_rod:', departure_rod)
    console.log('departure_rod.length:', departure_rod.length)
    console.log('destination_rod:', destination_rod)
    console.log('destination_rod.length:', destination_rod.length)

    if (departure_rod.length == 0) {
        console.log('move is impossible because the departure rod is empty')
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        console.log('move is possible because the destination rod is empty')
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    console.log('move is', destination_rod[0] > departure_rod[0] ? 'possible' : 'impossible',
                'because destination_rod[0] > departure_rod[0] is', destination_rod[0] > departure_rod[0])
    return destination_rod[0] > departure_rod[0];
}

function move(departure_rod_index, destination_rod_index) {
    // действия по перекладыванию диска будем выполнять только если это разрешено правилами
    if (is_move_possible(departure_rod_index, destination_rod_index)) {
        console.log('moving from',  departure_rod_index, 'to', destination_rod_index, 'on state', JSON.stringify(hanoi))
        top_disk = hanoi[departure_rod_index].shift() // снимаем диск сверху со стержня departure_rod
        console.log('top disk is', top_disk)
        hanoi[destination_rod_index].unshift(top_disk) // кладём его сверху на стержень destination_rod
        console.log('result state is', JSON.stringify(hanoi))
    } else {
        console.log('move',  departure_rod_index, destination_rod_index, 'on', JSON.stringify(hanoi), 'is considered impossible')
    }
}

function solve_hanoi(N, departure_rod_index, destination_rod_index) {
    console.log('solve_hanoi for N = ', N, 'departure_rod_index = ',
                departure_rod_index, 'destination_rod_index = ', destination_rod_index)
    if (N == 1) {
        console.log('we are in the branch N == 1')
        // просто перекладываем один диск
        move(departure_rod_index, destination_rod_index);
    }
    // для всех N > 1
    else {
        console.log('we are in the branch N > 1')
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod_index = get_intermediate_rod_index(departure_rod_index, destination_rod_index)

        // перекладываем верхнюю пирамидку из 2 дисков на промежуточный стержень
        solve_hanoi(N - 1, departure_rod_index, intermediate_rod_index)
        
        // перекладываем самый большой диск на целевой стержень
        move(departure_rod_index, destination_rod_index)
        
        // пирамидку с промежуточного стержня перекладываем на целевой
        solve_hanoi(N - 1, intermediate_rod_index, destination_rod_index)
    }
}

```

Дохрена кода получилось, не правда ли? Ну да ничего, там комментарии и отладочные вызовы две трети занимают. Что, кстати, норма. Закинем обновлённый код в консоль, и в который уже раз запустим нашу проверку:

![Ну теперь-то должно работать?](./img/2.5/hanoi-tower-console-8.png)

Работает! А как насчёт варианта с двумя дисками?

```javascript
hanoi = [[1, 2], [], []]
solve_hanoi(2, 0, 2)
JSON.stringify(hanoi)
```

![Опять двойка! Не беда, исправим!](./img/2.5/hanoi-tower-console-9.png)

Упс, ошибочка. Но вроде вполне понятная: `all_rods is not defined`, `переменная all_rods не определена`, в 6 строчке функции `get_intermediate_rod_index` (кликните по гиперссылке в сообщении об ошибке — попадёте в отладчик):

![Выясняем, что именно исправлять](./img/2.5/hanoi-tower-console-10.png)

Всё понятно: когда добавляли везде `_index`, проморгали строчку. Исправляем:

```javascript
function get_intermediate_rod_index(departure_rod_index, destination_rod_index) {
    // исходный массив стержней — просто три цифры
    all_rods_indexes = [0, 1, 2]
    
    // отфильтруем departure_rod встроенной функцией
    rod_indexess_without_departure = all_rods_indexes.filter(function (rod) { return rod != departure_rod })
    
    // отфильтруем destination_rod встроенной функцией
    only_one_rod_index_left = rod_indexess_without_departure.filter(function (rod) { return rod != destination_rod })
    
    // в all_rods должен к этому моменту остаться только один элемент,
    // его и вернём как номер промежуточного стержня:
    return only_one_rod_index_left[0]
}
```

Закидываем обновлённую функцию в консоль и запускаем проверочный код для N == 2 ещё раз:

![Всё работает, но опять не совсем так, как хотелось бы](./img/2.5/hanoi-tower-console-11.png)

Опять двадцать пять. Результат не тот. Зато все отладочные вызовы включены, и что случилось в техническом смысле — понятно, надо только прочитать.

> Текста дофига, если вы начали клевать носом или терять нить и/или мотивацию на этом моменте — это
> нормально, stay tuned и не сдавайтесь ;) Чуть-чуть осталось, зато потом с собственной отладкой проблем будет меньше

Читаем, что нам вывела отладка, и анализируем:

```bash
# наш код проверки
hanoi = [[1, 2], [], []]
solve_hanoi(2, 0, 2)
JSON.stringify(hanoi)

# началось выполнение, solve_hanoi(2, 0, 2)
solve_hanoi for N =  2 departure_rod_index =  0 destination_rod_index =  2
# попали в `else`, так как N не равно 1
we are in the branch N > 1
# происходит рекурсивный вызов solve_hanoi(1, 0, 2)
# хотим переложить верхнюю часть пирамиды на... крайний правый штырь?
# погоди-ка но ведь должны на средний, ведь крайний правый — это целевой,
# а по алгоритму перекладываем мы сперва на промежуточный!
solve_hanoi for N =  1 departure_rod_index =  0 destination_rod_index =  2
# дальше можно не читать пока, уже ясно что есть ошибка
```

Идём в исходник, смотрим на код:

```javascript
function solve_hanoi(N, departure_rod_index, destination_rod_index) {
    console.log('solve_hanoi for N = ', N, 'departure_rod_index = ',
                departure_rod_index, 'destination_rod_index = ', destination_rod_index)
    if (N == 1) {
        console.log('we are in the branch N == 1')
        // просто перекладываем один диск
        move(departure_rod_index, destination_rod_index);
    }
    // для всех N > 1
    else {
        console.log('we are in the branch N > 1')
        // определим, какой стержень остался для промежуточных действий,
        // учитывая указанные исходный и целевой стержни
        intermediate_rod_index = get_intermediate_rod_index(departure_rod_index, destination_rod_index)

        // перекладываем верхнюю пирамидку из 2 дисков на промежуточный стержень
        solve_hanoi(N - 1, departure_rod_index, intermediate_rod_index)
        
        // перекладываем самый большой диск на целевой стержень
        move(departure_rod_index, destination_rod_index)
        
        // пирамидку с промежуточного стержня перекладываем на целевой
        solve_hanoi(N - 1, intermediate_rod_index, destination_rod_index)
    }
}
```

Внимание на строчку `solve_hanoi(N - 1, departure_rod_index, intermediate_rod_index)` — вроде всё верно, но видимо мы не правильно получаем `intermediate_rod_index`. Получаем мы его в предыдущей строчке функцией `get_intermediate_rod_index` — а она у нас без отладочных вызовов, и что происходит внутри — загадка; ясно только что, похоже, вернула она не то, что нужно. Ну что ж, везде есть — и там будут!

```javascript
function get_intermediate_rod_index(departure_rod_index, destination_rod_index) {
    console.log('we are now inside get_intermediate_rod_index with params', departure_rod_index, destination_rod_index)

    // исходный массив стержней — просто три цифры
    all_rods_indexes = [0, 1, 2]
    console.log('all_rods_indexes', all_rods_indexes)
    
    // отфильтруем departure_rod встроенной функцией
    rod_indexess_without_departure = all_rods_indexes.filter(function (rod) { return rod != departure_rod })
    console.log('rod_indexess_without_departure', rod_indexess_without_departure)
    
    // отфильтруем destination_rod встроенной функцией
    only_one_rod_index_left = rod_indexess_without_departure.filter(function (rod) { return rod != destination_rod })
    console.log('only_one_rod_index_left', only_one_rod_index_left)
    
    // в all_rods должен к этому моменту остаться только один элемент,
    // его и вернём как номер промежуточного стержня:
    console.log('expected to be returned:', only_one_rod_index_left[0])
    return only_one_rod_index_left[0]
}
```

Закидываем обновлённую функцию в консоль, повторяем запуск проверочного кода:

![Как говорится "Re(12):всё готово"](./img/2.5/hanoi-tower-console-12.png)

Ну-ка, ну-ка... Что-то какая-то ересь тут происходит, не должно быть такого:

```
we are now inside get_intermediate_rod_index with params 0 2
all_rods_indexes [0, 1, 2]
rod_indexess_without_departure [0, 2]
only_one_rod_index_left [0, 2]
expected to be returned: 0
```

Смотрим пристальнее на код фильтрации: `rod_indexess_without_departure = all_rods_indexes.filter(function (rod) { return rod != departure_rod })`, а именно на саму фильтрующую функцию `function (rod) { return rod != departure_rod`. Косяк — параметр-то мы переименовали, у нас теперь `departure_rod_index`. Ошибка найдена — исправляем!

```javascript
function get_intermediate_rod_index(departure_rod_index, destination_rod_index) {
    console.log('we are now inside get_intermediate_rod_index with params', departure_rod_index, destination_rod_index)

    // исходный массив стержней — просто три цифры
    all_rods_indexes = [0, 1, 2]
    console.log('all_rods_indexes', all_rods_indexes)
    
    // отфильтруем departure_rod встроенной функцией
    rod_indexess_without_departure = all_rods_indexes.filter(function (rod_index) { return rod_index != departure_rod_index })
    console.log('rod_indexess_without_departure', rod_indexess_without_departure)
    
    // отфильтруем destination_rod встроенной функцией
    only_one_rod_index_left = rod_indexess_without_departure.filter(function (rod_index) { return rod_index != destination_rod_index })
    console.log('only_one_rod_index_left', only_one_rod_index_left)
    
    // в all_rods должен к этому моменту остаться только один элемент,
    // его и вернём как номер промежуточного стержня:
    console.log('expected to be returned:', only_one_rod_index_left[0])
    return only_one_rod_index_left[0]
}
```

Закидываем обновлённую формулу, запускаем тестовый пример... Уфф, работает! Слава тебе... ну в кого вы там верите, если верите?

![Re(13):всё готово](./img/2.5/hanoi-tower-console-13.png)

Кстати, тестовый пример для N = 1 в этот момент тоже запустить не грех. Он тоже работает — проверьте сами.

Но пора идти дальше, запускаем для N = 3:

```javascript
hanoi = [[1, 2, 3], [], []]
solve_hanoi(3, 0, 2)
JSON.stringify(hanoi)
```

![Re(14):всё готово... мля](./img/2.5/hanoi-tower-console-14.png)

$@*&!!! Да сколько же можно =) Опять что-то не так. Разбираем отладочную информацию (да, её додура — мы сами постарались). Хорошая идея — отформатировать отладочный вывод отступами

```bash
# это наш скрипт
hanoi = [[1, 2, 3], [], []]
solve_hanoi(3, 0, 2)
JSON.stringify(hanoi)

# пошло-поехало
solve_hanoi for N =  3 departure_rod_index =  0 destination_rod_index =  2

    # попали во вторую ветку solve_hanoi
    we are in the branch N > 1

    # и оттуда в get_intermediate_rod_index
        we are now inside get_intermediate_rod_index with params 0 2
        all_rods_indexes [0, 1, 2]
        rod_indexess_without_departure [1, 2]
        only_one_rod_index_left [1]
        expected to be returned: 1
        # пока всё неплохо, промежуточный стержень мы определили верно

    # пошёл рекурсивный вызов для перекладывания башенки
    # из двух верхних дисков на промежуточный стержень
    solve_hanoi for N =  2 departure_rod_index =  0 destination_rod_index =  1
        we are in the branch N > 1
            # снова в get_intermediate_rod_index
                we are now inside get_intermediate_rod_index with params 0 1
                all_rods_indexes [0, 1, 2]
                rod_indexess_without_departure [1, 2]
                only_one_rod_index_left [2]
                expected to be returned: 2
                # поскольку в рамках этой подзадачи мы перекладываем с 0 на 1 стержень,
                # 2 — это правильный номер для промежуточного стержня, всё в порядке

        # и снова рекурсивный вызов — мы дошли до решения задачи размером 1
        solve_hanoi for N =  1 departure_rod_index =  0 destination_rod_index =  2
            # вот и подтверждение — действительно речь уже о перекладывании башенки,
            # состоящей из единственного диска
            we are in the branch N == 1
                # ушли в move (см. исходник), проверяем там дозволенность хода
                    is_move_possible debug information:
                        departure_rod: [1, 2, 3]
                        departure_rod.length: 3
                        destination_rod: []
                        destination_rod.length: 0
                    move is possible because the destination rod is empty
                moving from 0 to 2 on state [[1,2,3],[],[]]
                    top disk is 1
                    result state is [[2,3],[],[1]]

        # из отладочного кода может быть неочевидно, но к этому моменту мы вышли из solve_hanoi(1, 0, 2)
        # перекладываем "большой диск" в рамках solve_hanoi(2, 0, 1)
            is_move_possible debug information:
                departure_rod: [2, 3]
                departure_rod.length: 2
                destination_rod: []
                destination_rod.length: 0
            move is possible because the destination rod is empty
            moving from 0 to 1 on state [[2,3],[],[1]]
                top disk is 2
                result state is [[3],[2],[1]]
        # большой диск переложили, перекладываем с промежуточного стержня на целевой маленький
        solve_hanoi for N =  1 departure_rod_index =  2 destination_rod_index =  1
            we are in the branch N == 1
                is_move_possible debug information:
                    departure_rod: [1]
                    departure_rod.length: 1
                    destination_rod: [2]
                    destination_rod.length: 1
                move is possible because destination_rod[0] > departure_rod[0] is true
                moving from 2 to 1 on state [[3],[2],[1]]
                    top disk is 1
                    result state is [[3],[1,2],[]]
        # ура, с перекладыванием башенки из двух верхних дисков на промежуточный диск,
        # то бишь solve_hanoi(2, 0, 1) — покончено, результат [[3],[1,2],[]] — достигнут

        # теперь перекладывается третий, самый крупный диск, на самый правый стержень
            is_move_possible debug information:
                departure_rod: [3]
                departure_rod.length: 1
                destination_rod: []
                destination_rod.length: 0
            move is possible because the destination rod is empty
            moving from 0 to 2 on state [[3],[1,2],[]]
                top disk is 3
                result state is [[],[1,2],[3]]
        # и нам опять всё удаётся

        # пора переложить с промежуточного диска на целевой башенку из двух дисков, и задача будет решена:
        # для этого у нас припасён ещё один рекурсивный вызов:
        solve_hanoi for N =  2 departure_rod_index =  2 destination_rod_index =  2
            we are in the branch N > 1
                we are now inside get_intermediate_rod_index with params 2 2
                    all_rods_indexes [0, 1, 2]
                    rod_indexess_without_departure [0, 1]
                    only_one_rod_index_left [0, 1]
                    expected to be returned: 0
                    # промежуточным стержнем на этот раз стал "нулевой" — он как раз пуст

                # и снова рекурсивный вызов, для задачи размера 1
                    solve_hanoi for N =  1 departure_rod_index =  2 destination_rod_index =  0
                        we are in the branch N == 1
                            is_move_possible debug information:
                                departure_rod: [3]
                                departure_rod.length: 1
                                destination_rod: []
                                destination_rod.length: 0
                            move is possible because the destination rod is empty
                            moving from 2 to 0 on state [[],[1,2],[3]]
                                top disk is 3
                            result state is [[3],[1,2],[]]
                            # ОПАЧКИ! а зачем это оно БОЛЬШОЙ диск переложило? Мы же единичку из [1,2] на среднем стержне двигать собирались!
                            # Дальше можно не читать, ошибка найдена
```

Отладочных данных стало как-то уж очень много. Часть отладочных вызовов имеет смысл выключить. Но мы не уверены, что они нам не понадобятся чуть позже, поэтому стирать их не будем — просто закомментируем. Например, отладку функций `is_move_possible` и `get_intermediate_rod_index` можно безопасно убрать, будет меньше шума:

```javascript
function get_intermediate_rod_index(departure_rod_index, destination_rod_index) {
    // console.log('we are now inside get_intermediate_rod_index with params', departure_rod_index, destination_rod_index)

    // исходный массив стержней — просто три цифры
    all_rods_indexes = [0, 1, 2]
    // console.log('all_rods_indexes', all_rods_indexes)
    
    // отфильтруем departure_rod встроенной функцией
    rod_indexess_without_departure = all_rods_indexes.filter(function (rod_index) { return rod_index != departure_rod_index })
    // console.log('rod_indexess_without_departure', rod_indexess_without_departure)
    
    // отфильтруем destination_rod встроенной функцией
    only_one_rod_index_left = rod_indexess_without_departure.filter(function (rod_index) { return rod_index != destination_rod_index })
    // console.log('only_one_rod_index_left', only_one_rod_index_left)
    
    // в all_rods должен к этому моменту остаться только один элемент,
    // его и вернём как номер промежуточного стержня:
    // console.log('expected to be returned:', only_one_rod_index_left[0])
    return only_one_rod_index_left[0]
}

function is_move_possible(departure_rod_index, destination_rod_index) {
    // сами списки дисков на стержнях мы можем получить по их индексам
    departure_rod = hanoi[departure_rod_index]
    destination_rod = hanoi[destination_rod_index]

    // вот здесь добавляем ещё одну отладку:
    // console.log('is_move_possible debug information:')
    // console.log('departure_rod:', departure_rod)
    // console.log('departure_rod.length:', departure_rod.length)
    // console.log('destination_rod:', destination_rod)
    // console.log('destination_rod.length:', destination_rod.length)

    if (departure_rod.length == 0) {
        //console.log('move is impossible because the departure rod is empty')
        // если исходный стержень пуст, перекладывать нечего — ход запрещён
        return false;
    }
    // до этой точки в коде мы дойдём только если исходный стержень не пуст
    if (destination_rod.length == 0) {
        //console.log('move is possible because the destination rod is empty')
        // если целевой стержень пуст, а перекладывать есть что — ход вполне неплох!
        return true;
    }
    // до этой точки мы дойдём только если как исходный, так и целевой стержни не пусты
    // ход возможен, если на целевом стержне верхний диск больше (по номеру), чем на исходном
    //console.log('move is', destination_rod[0] > departure_rod[0] ? 'possible' : 'impossible',
    //            'because destination_rod[0] > departure_rod[0] is', destination_rod[0] > departure_rod[0])
    return destination_rod[0] > departure_rod[0];
}
```

С частично-выключенной отладкой вывод даже в один экран поместится:

![Меньше отладки](./img/2.5/hanoi-tower-console-15.png)


### Реккурентная формула

TODO

#### Получение

TODO

#### Код

TODO

### Замкнутая форма

TODO

#### Получение

TODO

#### Код

TODO

### Конечный автомат

TODO